/*************************************
 * @author mazharul.islam 
 * 
 **************************************/

package chaotic;
import utilities.*;

import java.io.BufferedOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;


public class HuffmanDecoder{
	PriorityQueue<HuffmanNode> q = null;
	Map<Integer,String> symbol  = null;
	double x0 = 0.5;
	double p = 0.4;
	double alpha = 33.00;
	double beta = 33.00;
	int vm = 33;
	List<HuffmanNode> huffmannodes = null;
	Map<Integer, Integer> map = null;
	public HuffmanDecoder(Map<Integer, Integer> _map){
		map = _map;
		huffmannodes = new ArrayList<HuffmanNode>();
		symbol = new HashMap<Integer, String>();
	}

	/* for unit  testing purposes */
	public void decoder(String str) {
		HuffmanNode cur = q.peek();

		for(int i=0;i<str.length();i++) {
			//	System.out.println(cur.c);

			if(str.charAt(i)=='0') {
				cur = cur.left;
			}
			else {
				cur = cur.right;
			}
			if(cur.isLeaf()) {
				System.out.print(cur.c);
				cur = q.peek();
			}
		}
	}


	public void decoder(BitInputStream bis, BufferedOutputStream bos) {
		try {
			
			q = buildTree();
			buildHuffmanTreeTable(q.peek(),"");
			addNodes(q.peek(), huffmannodes);
			HuffmanNode cur = q.peek();
			int bit;
			boolean flag = true;
			double xn = 0;
			while(true) {
				//	System.out.println(cur.c);
				if(flag) {
					flag = false;
					int n = 1+vm%10;
					xn = chaoticMap(x0, n);
					//System.out.println(xn);
					Double r = Math.floor(xn *Math.pow(2.00, alpha) + 
							vm * Math.pow(2.00, beta)) % huffmannodes.size();
					Integer ri = r.intValue();
					//System.out.println("ri = " +ri);
					HuffmanNode h = huffmannodes.get(ri);
					h.swap();
					buildHuffmanTreeTable(h, h.encodedString);
					
				}
				bit = bis.read();
				
				if(bit == -1) break;
				
				if(bit==0) {
					cur = cur.left;
				}
				else {
					cur = cur.right;
				}
				if(cur.isLeaf()) {
					bos.write(cur.c);
					flag = true;
					//System.out.println("c  = " +cur.c);
					vm = cur.c;
					x0 = xn;
					cur = q.peek();
				}
			}
		}catch(Exception ex) {
			System.out.println("while decoding " + ex.toString());
			ex.printStackTrace();
		}
	}


//	public static void main(String[] args) {

private void buildHuffmanTreeTable(HuffmanNode root, String s) {
	
		
	//	if(root==null) {
	//		System.out.println(s);
	//		return ;
	//	}
		root.encodedString = s;
		// base case; if the left and right are null 
		// then its a leaf node and we print 
		// the code s generated by traversing the tree. 
		if (root.isLeaf()){
		//	if(symbol.containsKey(root.c)
		//		&& !symbol.get(root.c).equals(root.encodedString)) {
		//		System.out.println( " {Prev} = " + symbol.get(root.c)+ " "+ " {Now} = " + s);
		//	}
			// c is the character in the node 
	//		System.out.println(root.c + ":" + s); 
			//len += s.length()*root.data;
		//	root.encodedString = s;
		//	System.out.println(root.c);
			
			symbol.put(root.c, root.encodedString);
			return; 
		} 

		// if we go to left then add "0" to the code. 
		// if we go to the right add"1" to the code. 

		// recursive calls for left and 
		// right sub-tree of the generated tree.
		//root.encodedString = s;
		buildHuffmanTreeTable(root.left, root.encodedString+"0"); 
		buildHuffmanTreeTable(root.right, root.encodedString+"1"); 
		
	}

	//	}
	public  PriorityQueue<HuffmanNode>  buildTree(){
		// creating a priority queue q. 
		// makes a min-priority queue(min-heap). 
		int n = map.size();
		//System.out.println("N = "+n);
		 q  = new PriorityQueue<HuffmanNode>(n, new MyComparator()); 

		for (Integer key: map.keySet()) { 
 
			HuffmanNode hn = new HuffmanNode(); 

			hn.c = key; 
			hn.data = map.get(key); 

			hn.left = null; 
			hn.right = null; 

			// add functions adds 
			// the huffman node to the queue.
			
			q.add(hn); 
		} 

		// create a root node 
	//	HuffmanNode root = null; 

		// Here we will extract the two minimum value 
		// from the heap each time until 
		// its size reduces to 1, extract until 
		// all the nodes are extracted. 
		while (q.size() > 1) { 

			// first min extract. 
			HuffmanNode x = q.peek(); 
			q.poll(); 

			// second min extarct. 
			HuffmanNode y = q.peek(); 
			q.poll(); 

			// new node f which is equal 
			HuffmanNode f = new HuffmanNode(); 

			// to the sum of the frequency of the two nodes 
			// assigning values to the f node. 
			f.data = x.data + y.data; 
			f.c = -1; 

			// first extracted node as left child. 
			f.left = x; 

			// second extracted node as the right child. 
			f.right = y; 

			// marking the f node as the root node. 
		//	root = f; 

			// add this node to the priority-queue. 
			q.add(f); 
		} 

		return q;
	}
	public void addNodes(HuffmanNode cur, List<HuffmanNode> nodes) {
		nodes.add(cur);
		if(cur.isLeaf()) {
			
			return ;
		}
		addNodes(cur.left, nodes); 
		addNodes(cur.right, nodes);
	}
	private double chaoticMap(double x0,int n) {
		double x = x0;
		for(int i=0;i<n;i++) {
			if(x<=p) {
				x = x/p;
			}
			else {
				x = (1-x)/(1-p);
			}
		}
		return x;
	}


}
