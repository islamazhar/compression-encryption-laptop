/*************************************
 * @author mazharul.islam 
 * 
 **************************************/

package classical;
import utilities.*;

import java.io.BufferedOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;


public class HuffmanDecoder{
	PriorityQueue<HuffmanNode> q = null;
	Map<Integer,String> symbol  = null;
	Map<Integer, Integer> map = null;
	public HuffmanDecoder(Map<Integer, Integer> _map){
		map = _map;
		symbol = new HashMap<Integer, String>();
	}

	/* for unit  testing purposes */
	public void decoder(String str) {
		HuffmanNode cur = q.peek();

		for(int i=0;i<str.length();i++) {
			//	System.out.println(cur.c);

			if(str.charAt(i)=='0') {
				cur = cur.left;
			}
			else {
				cur = cur.right;
			}
			if(cur.isLeaf()) {
				System.out.print(cur.c);
				cur = q.peek();
			}
		}
	}


	public void decoder(BitInputStream bis, BufferedOutputStream bos) {
		try {
			
			q = buildTree();
			buildHuffmanTreeTable(q.peek(),"");
			HuffmanNode cur = q.peek();
			int bit;
			boolean flag = true;
			double xn = 0;
			while(true) {
				bit = bis.read();
				
				if(bit == -1) break;
				
				if(bit==0) {
					cur = cur.left;
				}
				else {
					cur = cur.right;
				}
				if(cur.isLeaf()) {
					bos.write(cur.c);
					cur = q.peek();
				}
			}
		}catch(Exception ex) {
			System.out.println("while decoding " + ex.toString());
			ex.printStackTrace();
		}
	}


//	public static void main(String[] args) {

private void buildHuffmanTreeTable(HuffmanNode root, String s) {
	
		
	//	if(root==null) {
	//		System.out.println(s);
	//		return ;
	//	}
		root.encodedString = s;
		// base case; if the left and right are null 
		// then its a leaf node and we print 
		// the code s generated by traversing the tree. 
		if (root.isLeaf()){
		//	if(symbol.containsKey(root.c)
		//		&& !symbol.get(root.c).equals(root.encodedString)) {
		//		System.out.println( " {Prev} = " + symbol.get(root.c)+ " "+ " {Now} = " + s);
		//	}
			// c is the character in the node 
	//		System.out.println(root.c + ":" + s); 
			//len += s.length()*root.data;
		//	root.encodedString = s;
		//	System.out.println(root.c);
			
			symbol.put(root.c, root.encodedString);
			return; 
		} 

		// if we go to left then add "0" to the code. 
		// if we go to the right add"1" to the code. 

		// recursive calls for left and 
		// right sub-tree of the generated tree.
		//root.encodedString = s;
		buildHuffmanTreeTable(root.left, root.encodedString+"0"); 
		buildHuffmanTreeTable(root.right, root.encodedString+"1"); 
		
	}

	//	}
	public  PriorityQueue<HuffmanNode>  buildTree(){
		// creating a priority queue q. 
		// makes a min-priority queue(min-heap). 
		int n = map.size();
		//System.out.println("N = "+n);
		 q  = new PriorityQueue<HuffmanNode>(n, new MyComparator()); 

		for (Integer key: map.keySet()) { 
 
			HuffmanNode hn = new HuffmanNode(); 

			hn.c = key; 
			hn.data = map.get(key); 

			hn.left = null; 
			hn.right = null; 

			// add functions adds 
			// the huffman node to the queue.
			
			q.add(hn); 
		} 

		// create a root node 
	//	HuffmanNode root = null; 

		// Here we will extract the two minimum value 
		// from the heap each time until 
		// its size reduces to 1, extract until 
		// all the nodes are extracted. 
		while (q.size() > 1) { 

			// first min extract. 
			HuffmanNode x = q.peek(); 
			q.poll(); 

			// second min extarct. 
			HuffmanNode y = q.peek(); 
			q.poll(); 

			// new node f which is equal 
			HuffmanNode f = new HuffmanNode(); 

			// to the sum of the frequency of the two nodes 
			// assigning values to the f node. 
			f.data = x.data + y.data; 
			f.c = -1; 

			// first extracted node as left child. 
			f.left = x; 

			// second extracted node as the right child. 
			f.right = y; 

			// marking the f node as the root node. 
		//	root = f; 

			// add this node to the priority-queue. 
			q.add(f); 
		} 

		return q;
	}
}
