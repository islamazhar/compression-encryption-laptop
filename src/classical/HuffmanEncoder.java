/*************************************
 * @author mazharul.islam 
 * 
 **************************************/

package classical;


import utilities.*;
import java.util.PriorityQueue;
import java.util.HashMap;
import java.util.List;
import java.util.Map; 

public class HuffmanEncoder { 
	public Map<Integer, Integer> map = null;
	public int len =0;
	Map<Integer,String> symbol=new HashMap<Integer,String>();
	
	
	public HuffmanEncoder(Map<Integer,Integer>_map) {
		map = _map;
	}
	// recursive function to print the 
	// huffman-code through the tree traversal. 
	// Here s is the huffman - code generated. 
	public  void buildHuffmanTreeTable(HuffmanNode root, String s) 
	{ 
		
		
		root.encodedString = s;
		// base case; if the left and right are null 
		// then its a leaf node and we print 
		// the code s generated by traversing the tree. 
		if (root.isLeaf()) {
		//	if(symbol.containsKey(root.c)
		//		&& !symbol.get(root.c).equals(root.encodedString)) {
		//		System.out.println( " {Prev} = " + symbol.get(root.c)+ " "+ " {Now} = " + s);
		//	}
			// c is the character in the node 
	//		System.out.println(root.c + ":" + s); 
			//len += s.length()*root.data;
		//	root.encodedString = s;
		//	System.out.println(root.c);
			
			symbol.put(root.c, root.encodedString);
			return; 
		} 

		// if we go to left then add "0" to the code. 
		// if we go to the right add"1" to the code. 

		// recursive calls for left and 
		// right sub-tree of the generated tree.
		//root.encodedString = s;
		buildHuffmanTreeTable(root.left, root.encodedString+"0"); 
		buildHuffmanTreeTable(root.right, root.encodedString+"1"); 
	}
	public void print(HuffmanNode root) {
		if(root.isLeaf()) {
			System.out.println(root.c+ " "+ symbol.get(root.c));
			return ;
		}
		print(root.left); 
		print(root.right); 
		
	}

	// main function 
	public  PriorityQueue<HuffmanNode>  buildTree(){
		// creating a priority queue q. 
		// makes a min-priority queue(min-heap). 
		int n = map.size();
		PriorityQueue<HuffmanNode> q 
		= new PriorityQueue<HuffmanNode>(n, new MyComparator()); 

		for (Integer key: map.keySet()) { 
 
			HuffmanNode hn = new HuffmanNode(); 

			hn.c = key; 
			hn.data = map.get(key); 

			hn.left = null; 
			hn.right = null; 

			// add functions adds 
			// the huffman node to the queue.
			
			q.add(hn); 
		} 

		// create a root node 
	//	HuffmanNode root = null; 

		// Here we will extract the two minimum value 
		// from the heap each time until 
		// its size reduces to 1, extract until 
		// all the nodes are extracted. 
		while (q.size() > 1) { 

			// first min extract. 
			HuffmanNode x = q.peek(); 
			q.poll(); 

			// second min extarct. 
			HuffmanNode y = q.peek(); 
			q.poll(); 

			// new node f which is equal 
			HuffmanNode f = new HuffmanNode(); 

			// to the sum of the frequency of the two nodes 
			// assigning values to the f node. 
			f.data = x.data + y.data; 
			f.c = -1; 

			// first extracted node as left child. 
			f.left = x; 

			// second extracted node as the right child. 
			f.right = y; 

			// marking the f node as the root node. 
		//	root = f; 

			// add this node to the priority-queue. 
			q.add(f); 
		} 

		return q;
	}

//	public static void main(String[] args) 
//	{ 

//	} 
}  
